
# APIVersion defines the versioned schema of this representation of an object.
# Servers should convert recognized schemas to the latest internal value, and
# may reject unrecognized values.
# More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
apiVersion: ""

# CacheNamespace if specified restricts the manager's cache to watch objects in
# the desired namespace Defaults to all namespaces
#
# Note: If a namespace is specified, controllers can still Watch for a
# cluster-scoped resource (e.g Node).  For namespaced resources the cache
# will only hold objects from the desired namespace.
cacheNamespace: ""

# Controller contains global configuration options for controllers
# registered within this manager.
controller:

  # CacheSyncTimeout refers to the time limit set to wait for syncing caches.
  # Defaults to 2 minutes if not set.
  cacheSyncTimeout: 0

  # GroupKindConcurrency is a map from a Kind to the number of concurrent reconciliation
  # allowed for that controller.
  #
  # When a controller is registered within this manager using the builder utilities,
  # users have to specify the type the controller reconciles in the For(...) call.
  # If the object's kind passed matches one of the keys in this map, the concurrency
  # for that controller is set to the number specified.
  #
  # The key is expected to be consistent in form with GroupKind.String(),
  # e.g. ReplicaSet in apps group (regardless of version) would be `ReplicaSet.apps`.
  groupKindConcurrency:
    "key": 0

  # RecoverPanic indicates if panics should be recovered.
  recoverPanic: false

# Distribution defines the operator distribution name.
distribution: ""

# FeatureGates is the supported set of all operator feature gates.
featureGates:

  # BuiltInCertManagement enables the built-in facility for generating and rotating
  # TLS client and serving certificates for the communication between ingesters and distributors and also between
  # query and query-frontend, In detail all internal Tempo HTTP and GRPC communication is lifted
  # to require mTLS.
  # In addition each service requires a configmap named as the MicroService CR with the
  # suffix `-ca-bundle`, e.g. `tempo-dev-ca-bundle` and the following data:
  # - `service-ca.crt`: The CA signing the service certificate in `tls.crt`.
  # All necessary secrets and configmaps for protecting the internal components will be created if this
  # option is enabled.
  builtInCertManagement:

    # Enabled defines to flag to enable/disable built-in certificate management feature gate.
    enabled: false

    # CACertRefresh defines the duration of the CA certificate validity until a rotation
    # should happen. It can be set up to 80% of CA certificate validity or equal to the
    # CA certificate validity. Latter should be used only for rotating only when expired.
    caRefresh: 0h

    # CACertValidity defines the total duration of the CA certificate validity.
    caValidity: 0h

    # CertRefresh defines the duration of the certificate validity until a rotation
    # should happen. It can be set up to 80% of certificate validity or equal to the
    # certificate validity. Latter should be used only for rotating only when expired.
    # The refresh is applied to all Tempo certificates at once.
    certRefresh: 0h

    # CertValidity defines the total duration of the validity for all Tempo certificates.
    certValidity: 0h

  # GrafanaOperator defines whether the Grafana Operator CRD exists in the cluster.
  # This CRD is part of grafana-operator.
  grafanaOperator: false

  # GRPCEncryption enables TLS encryption for all GRPC TempoStack services.
  # Each GRPC component requires a secret, the name should be the name of the component with the
  # suffix `-mtls` and prefix by the TempoStack name e.g `tempo-dev-distributor-mtls`.
  # It should contains the following data:
  # - `tls.crt`: The TLS server side certificate.
  # - `tls.key`: The TLS key for server-side encryption.
  # In addition each service requires a configmap named as the TempoStack CR with the
  # suffix `-ca-bundle`, e.g. `tempo-dev-ca-bundle` and the following data:
  # - `service-ca.crt`: The CA signing the service certificate in `tls.crt`.
  # This will protect all internal communication between the distributors and ingestors and also
  # between ingestor and queriers, and between the queriers and the query-frontend component.
  #
  # If BuiltInCertManagement is enabled, you don't need to create this secrets manually.
  #
  # Some considerations when enable mTLS:
  # - If JaegerUI is enabled, it won´t be protected by mTLS as it will be considered a public face
  # component.
  # - If Gateway is enabled, all comunications between the gateway and the tempo components will be protected
  # by mTLS, and the Gateway itself won´t be, as it will be the only public face component.
  grpcEncryption: false

  # HTTPEncryption enables TLS encryption for all HTTP TempoStack components.
  # Each HTTP component requires a secret, the name should be the name of the component with the
  # suffix `-mtls` and prefix by the TempoStack name e.g `tempo-dev-distributor-mtls`.
  # It should contains the following data:
  # - `tls.crt`: The TLS server side certificate.
  # - `tls.key`: The TLS key for server-side encryption.
  # In addition each service requires a configmap named as the TempoStack CR with the
  # suffix `-ca-bundle`, e.g. `tempo-dev-ca-bundle` and the following data:
  # - `service-ca.crt`: The CA signing the service certificate in `tls.crt`.
  # This will protect all internal communication between the distributors and ingestors and also
  # between ingestor and queriers, and between the queriers and the query-frontend component
  #
  # If BuiltInCertManagement is enabled, you don't need to create this secrets manually.
  #
  # Some considerations when enable mTLS:
  # - If JaegerUI is enabled, it won't be protected by mTLS as it will be considered a public facing
  # component.
  # - If JaegerUI is not enabled, HTTP Tempo API won´t be protected, this will be considered
  # public faced component.
  # - If Gateway is enabled, all comunications between the gateway and the tempo components will be protected
  # by mTLS, and the Gateway itself won´t be, as it will be the only public face component.
  httpEncryption: false

  # Observability configures observability features of the operator.
  observability:

    # Metrics configures metrics of the operator.
    metrics:

      # CreatePrometheusRules defines whether the operator should install PrometheusRules
      # to receive alerts about the operator.
      createPrometheusRules: false

      # CreateServiceMonitors defines whether the operator should install ServiceMonitors
      # to scrape metrics of the operator.
      createServiceMonitors: false

  # OpenShift contains a set of feature gates supported only on OpenShift.
  openshift:

    # BaseDomain is used internally for redirect URL in gateway OpenShift auth mode.
    # If empty the operator automatically derives the domain from the cluster.
    baseDomain: ""

    # OauthProxy define options for the oauth proxy feature.
    oAuthProxy:

      # OAuthProxyEnabled is used internally for enable by default the oauth proxy for the UI when multi-tenancy is disabled.
      defaultEnabled: false

    # OpenShiftRoute enables creating OpenShift Route objects.
    # More details: https://docs.openshift.com/container-platform/latest/networking/understanding-networking.html
    openshiftRoute: false

    # ServingCertsService enables OpenShift service-ca annotations on the TempoStack gateway service only
    # to use the in-platform CA and generate a TLS cert/key pair per service for
    # in-cluster data-in-transit encryption.
    # More details: https://docs.openshift.com/container-platform/latest/security/certificate_types_descriptions/service-ca-certificates.html
    servingCertsService: false

  # PrometheusOperator defines whether the Prometheus Operator CRD exists in the cluster.
  # This CRD is part of prometheus-operator.
  prometheusOperator: false

  # TLSProfile allows to chose a TLS security profile. Enforced
  # when using HTTPEncryption or GRPCEncryption.
  tlsProfile: ""

# GracefulShutdownTimeout is the duration given to runnable to stop before the manager actually returns on stop.
# To disable graceful shutdown, set to time.Duration(0)
# To use graceful shutdown without timeout, set to a negative duration, e.G. time.Duration(-1)
# The graceful shutdown is skipped for safety reasons in case the leader election lease is lost.
gracefulShutDown: 0h

# Health contains the controller health configuration
health:

  # HealthProbeBindAddress is the TCP address that the controller should bind to
  # for serving health probes
  # It can be set to "0" or "" to disable serving the health probe.
  healthProbeBindAddress: ""

  # LivenessEndpointName, defaults to "healthz"
  livenessEndpointName: ""

  # ReadinessEndpointName, defaults to "readyz"
  readinessEndpointName: ""

# Kind is a string value representing the REST resource this object represents.
# Servers may infer this from the endpoint the client submits requests to.
# Cannot be updated.
# In CamelCase.
# More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
kind: ""

# LeaderElection is the LeaderElection config to be used when configuring
# the manager.Manager leader election
leaderElection:

  # leaderElect enables a leader election client to gain leadership
  # before executing the main loop. Enable this when running replicated
  # components for high availability.
  leaderElect: false

  # leaseDuration is the duration that non-leader candidates will wait
  # after observing a leadership renewal until attempting to acquire
  # leadership of a led but unrenewed leader slot. This is effectively the
  # maximum duration that a leader can be stopped before it is replaced
  # by another candidate. This is only applicable if leader election is
  # enabled.
  leaseDuration: 0h

  # renewDeadline is the interval between attempts by the acting master to
  # renew a leadership slot before it stops leading. This must be less
  # than or equal to the lease duration. This is only applicable if leader
  # election is enabled.
  renewDeadline: 0h

  # resourceLock indicates the resource object type that will be used to lock
  # during leader election cycles.
  resourceLock: ""

  # resourceName indicates the name of resource object that will be used to lock
  # during leader election cycles.
  resourceName: ""

  # resourceName indicates the namespace of resource object that will be used to lock
  # during leader election cycles.
  resourceNamespace: ""

  # retryPeriod is the duration the clients should wait between attempting
  # acquisition and renewal of a leadership. This is only applicable if
  # leader election is enabled.
  retryPeriod: 0h

# Metrics contains the controller metrics configuration
metrics:

  # BindAddress is the TCP address that the controller should bind to
  # for serving prometheus metrics.
  # It can be set to "0" to disable the metrics serving.
  bindAddress: ""

# SyncPeriod determines the minimum frequency at which watched resources are
# reconciled. A lower period will correct entropy more quickly, but reduce
# responsiveness to change if there are many watched resources. Change this
# value only if you know what you are doing. Defaults to 10 hours if unset.
# there will a 10 percent jitter between the SyncPeriod of all controllers
# so that all controllers will not send list requests simultaneously.
syncPeriod: 0h

# Webhook contains the controllers webhook configuration
webhook:

  # CertDir is the directory that contains the server key and certificate.
  # if not set, webhook server would look up the server key and certificate in
  # {TempDir}/k8s-webhook-server/serving-certs. The server key and certificate
  # must be named tls.key and tls.crt, respectively.
  certDir: ""

  # Host is the hostname that the webhook server binds to.
  # It is used to set webhook.Server.Host.
  host: ""

  # Port is the port that the webhook server serves at.
  # It is used to set webhook.Server.Port.
  port: 0
