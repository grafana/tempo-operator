
# APIVersion defines the versioned schema of this representation of an object.
# Servers should convert recognized schemas to the latest internal value, and
# may reject unrecognized values.
# More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
apiVersion: ""

# Distribution defines the operator distribution name.
distribution: ""

# FeatureGates is the supported set of all operator feature gates.
featureGates:

  # BuiltInCertManagement enables the built-in facility for generating and rotating
  # TLS client and serving certificates for the communication between ingesters and distributors and also between
  # query and query-frontend, In detail all internal Tempo HTTP and GRPC communication is lifted
  # to require mTLS.
  # In addition each service requires a configmap named as the MicroService CR with the
  # suffix `-ca-bundle`, e.g. `tempo-dev-ca-bundle` and the following data:
  # - `service-ca.crt`: The CA signing the service certificate in `tls.crt`.
  # All necessary secrets and configmaps for protecting the internal components will be created if this
  # option is enabled.
  builtInCertManagement:

    # Enabled defines to flag to enable/disable built-in certificate management feature gate.
    enabled: false

    # CACertRefresh defines the duration of the CA certificate validity until a rotation
    # should happen. It can be set up to 80% of CA certificate validity or equal to the
    # CA certificate validity. Latter should be used only for rotating only when expired.
    caRefresh: 0h

    # CACertValidity defines the total duration of the CA certificate validity.
    caValidity: 0h

    # CertRefresh defines the duration of the certificate validity until a rotation
    # should happen. It can be set up to 80% of certificate validity or equal to the
    # certificate validity. Latter should be used only for rotating only when expired.
    # The refresh is applied to all Tempo certificates at once.
    certRefresh: 0h

    # CertValidity defines the total duration of the validity for all Tempo certificates.
    certValidity: 0h

  # DefaultPodSecurityContext defines the default pod security context to apply to all pods
  # when specific fields are not set. Fields from this default are merged into pod security
  # contexts that have nil values for those fields.
  # For Community distributions, set fsGroup: 10001 to ensure volume permissions work correctly
  # with certain CSI drivers (AWS EBS, DigitalOcean, etc.) that mount volumes with root:root ownership.
  # On OpenShift, SCCs manage security contexts automatically, so this should be set to an empty object {}.
  defaultPodSecurityContext:

    # appArmorProfile is the AppArmor options to use by the containers in this pod.
    # Note that this field cannot be set when spec.os.name is windows.
    appArmorProfile:

      # localhostProfile indicates a profile loaded on the node that should be used.
      # The profile must be preconfigured on the node to work.
      # Must match the loaded name of the profile.
      # Must be set if and only if type is "Localhost".
      localhostProfile: ""

      # type indicates which kind of AppArmor profile will be applied.
      # Valid options are:
      #   Localhost - a profile pre-loaded on the node.
      #   RuntimeDefault - the container runtime's default profile.
      #   Unconfined - no AppArmor enforcement.
      type: ""

    # A special supplemental group that applies to all containers in a pod.
    # Some volume types allow the Kubelet to change the ownership of that volume
    # to be owned by the pod:
    #
    # 1. The owning GID will be the FSGroup
    # 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
    # 3. The permission bits are OR'd with rw-rw----
    #
    # If unset, the Kubelet will not modify the ownership and permissions of any volume.
    # Note that this field cannot be set when spec.os.name is windows.
    fsGroup: 0

    # fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
    # before being exposed inside Pod. This field will only apply to
    # volume types which support fsGroup based ownership(and permissions).
    # It will have no effect on ephemeral volume types such as: secret, configmaps
    # and emptydir.
    # Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
    # Note that this field cannot be set when spec.os.name is windows.
    fsGroupChangePolicy: ""

    # The GID to run the entrypoint of the container process.
    # Uses runtime default if unset.
    # May also be set in SecurityContext.  If set in both SecurityContext and
    # PodSecurityContext, the value specified in SecurityContext takes precedence
    # for that container.
    # Note that this field cannot be set when spec.os.name is windows.
    runAsGroup: 0

    # Indicates that the container must run as a non-root user.
    # If true, the Kubelet will validate the image at runtime to ensure that it
    # does not run as UID 0 (root) and fail to start the container if it does.
    # If unset or false, no such validation will be performed.
    # May also be set in SecurityContext.  If set in both SecurityContext and
    # PodSecurityContext, the value specified in SecurityContext takes precedence.
    runAsNonRoot: false

    # The UID to run the entrypoint of the container process.
    # Defaults to user specified in image metadata if unspecified.
    # May also be set in SecurityContext.  If set in both SecurityContext and
    # PodSecurityContext, the value specified in SecurityContext takes precedence
    # for that container.
    # Note that this field cannot be set when spec.os.name is windows.
    runAsUser: 0

    # seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.
    # It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
    # Valid values are "MountOption" and "Recursive".
    #
    # "Recursive" means relabeling of all files on all Pod volumes by the container runtime.
    # This may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.
    #
    # "MountOption" mounts all eligible Pod volumes with `-o context` mount option.
    # This requires all Pods that share the same volume to use the same SELinux label.
    # It is not possible to share the same volume among privileged and unprivileged Pods.
    # Eligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes
    # whose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their
    # CSIDriver instance. Other volumes are always re-labelled recursively.
    # "MountOption" value is allowed only when SELinuxMount feature gate is enabled.
    #
    # If not specified and SELinuxMount feature gate is enabled, "MountOption" is used.
    # If not specified and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes
    # and "Recursive" for all other volumes.
    #
    # This field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.
    #
    # All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.
    # Note that this field cannot be set when spec.os.name is windows.
    seLinuxChangePolicy: ""

    # The SELinux context to be applied to all containers.
    # If unspecified, the container runtime will allocate a random SELinux context for each
    # container.  May also be set in SecurityContext.  If set in
    # both SecurityContext and PodSecurityContext, the value specified in SecurityContext
    # takes precedence for that container.
    # Note that this field cannot be set when spec.os.name is windows.
    seLinuxOptions:

      # Level is SELinux level label that applies to the container.
      level: ""

      # Role is a SELinux role label that applies to the container.
      role: ""

      # Type is a SELinux type label that applies to the container.
      type: ""

      # User is a SELinux user label that applies to the container.
      user: ""

    # The seccomp options to use by the containers in this pod.
    # Note that this field cannot be set when spec.os.name is windows.
    seccompProfile:

      # localhostProfile indicates a profile defined in a file on the node should be used.
      # The profile must be preconfigured on the node to work.
      # Must be a descending path, relative to the kubelet's configured seccomp profile location.
      # Must be set if type is "Localhost". Must NOT be set for any other type.
      localhostProfile: ""

      # type indicates which kind of seccomp profile will be applied.
      # Valid options are:
      #
      # Localhost - a profile defined in a file on the node should be used.
      # RuntimeDefault - the container runtime default profile should be used.
      # Unconfined - no profile should be applied.
      type: ""

    # A list of groups applied to the first process run in each container, in
    # addition to the container's primary GID and fsGroup (if specified).  If
    # the SupplementalGroupsPolicy feature is enabled, the
    # supplementalGroupsPolicy field determines whether these are in addition
    # to or instead of any group memberships defined in the container image.
    # If unspecified, no additional groups are added, though group memberships
    # defined in the container image may still be used, depending on the
    # supplementalGroupsPolicy field.
    # Note that this field cannot be set when spec.os.name is windows.
    supplementalGroups:

    # A list of groups applied to the first process run in each container, in
    # addition to the container's primary GID and fsGroup (if specified).  If
    # the SupplementalGroupsPolicy feature is enabled, the
    # supplementalGroupsPolicy field determines whether these are in addition
    # to or instead of any group memberships defined in the container image.
    # If unspecified, no additional groups are added, though group memberships
    # defined in the container image may still be used, depending on the
    # supplementalGroupsPolicy field.
    # Note that this field cannot be set when spec.os.name is windows.
    - 0

    # Defines how supplemental groups of the first container processes are calculated.
    # Valid values are "Merge" and "Strict". If not specified, "Merge" is used.
    # (Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled
    # and the container runtime must implement support for this feature.
    # Note that this field cannot be set when spec.os.name is windows.
    # TODO: update the default value to "Merge" when spec.os.name is not windows in v1.34
    supplementalGroupsPolicy: ""

    # Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
    # sysctls (by the container runtime) might fail to launch.
    # Note that this field cannot be set when spec.os.name is windows.
    sysctls:

      # Name of a property to set
    - name: ""

      # Value of a property to set
      value: ""

    # The Windows specific settings applied to all containers.
    # If unspecified, the options within a container's SecurityContext will be used.
    # If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
    # Note that this field cannot be set when spec.os.name is linux.
    windowsOptions:

      # GMSACredentialSpec is where the GMSA admission webhook
      # (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
      # GMSA credential spec named by the GMSACredentialSpecName field.
      gmsaCredentialSpec: ""

      # GMSACredentialSpecName is the name of the GMSA credential spec to use.
      gmsaCredentialSpecName: ""

      # HostProcess determines if a container should be run as a 'Host Process' container.
      # All of a Pod's containers must have the same effective HostProcess value
      # (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
      # In addition, if HostProcess is true then HostNetwork must also be set to true.
      hostProcess: false

      # The UserName in Windows to run the entrypoint of the container process.
      # Defaults to the user specified in image metadata if unspecified.
      # May also be set in PodSecurityContext. If set in both SecurityContext and
      # PodSecurityContext, the value specified in SecurityContext takes precedence.
      runAsUserName: ""

  # GrafanaOperator defines whether the Grafana Operator CRD exists in the cluster.
  # This CRD is part of grafana-operator.
  grafanaOperator: false

  # GRPCEncryption enables TLS encryption for all GRPC TempoStack services.
  # Each GRPC component requires a secret, the name should be the name of the component with the
  # suffix `-mtls` and prefix by the TempoStack name e.g `tempo-dev-distributor-mtls`.
  # It should contains the following data:
  # - `tls.crt`: The TLS server side certificate.
  # - `tls.key`: The TLS key for server-side encryption.
  # In addition each service requires a configmap named as the TempoStack CR with the
  # suffix `-ca-bundle`, e.g. `tempo-dev-ca-bundle` and the following data:
  # - `service-ca.crt`: The CA signing the service certificate in `tls.crt`.
  # This will protect all internal communication between the distributors and ingestors and also
  # between ingestor and queriers, and between the queriers and the query-frontend component.
  #
  # If BuiltInCertManagement is enabled, you don't need to create this secrets manually.
  #
  # Some considerations when enable mTLS:
  # - If JaegerUI is enabled, it won´t be protected by mTLS as it will be considered a public face
  # component.
  # - If Gateway is enabled, all comunications between the gateway and the tempo components will be protected
  # by mTLS, and the Gateway itself won´t be, as it will be the only public face component.
  grpcEncryption: false

  # HTTPEncryption enables TLS encryption for all HTTP TempoStack components.
  # Each HTTP component requires a secret, the name should be the name of the component with the
  # suffix `-mtls` and prefix by the TempoStack name e.g `tempo-dev-distributor-mtls`.
  # It should contains the following data:
  # - `tls.crt`: The TLS server side certificate.
  # - `tls.key`: The TLS key for server-side encryption.
  # In addition each service requires a configmap named as the TempoStack CR with the
  # suffix `-ca-bundle`, e.g. `tempo-dev-ca-bundle` and the following data:
  # - `service-ca.crt`: The CA signing the service certificate in `tls.crt`.
  # This will protect all internal communication between the distributors and ingestors and also
  # between ingestor and queriers, and between the queriers and the query-frontend component
  #
  # If BuiltInCertManagement is enabled, you don't need to create this secrets manually.
  #
  # Some considerations when enable mTLS:
  # - If JaegerUI is enabled, it won't be protected by mTLS as it will be considered a public facing
  # component.
  # - If JaegerUI is not enabled, HTTP Tempo API won´t be protected, this will be considered
  # public faced component.
  # - If Gateway is enabled, all comunications between the gateway and the tempo components will be protected
  # by mTLS, and the Gateway itself won´t be, as it will be the only public face component.
  httpEncryption: false

  # NetworkPolicies enables creating network policy objects.
  networkPolicies: false

  # Observability configures observability features of the operator.
  observability:

    # Metrics configures metrics of the operator.
    metrics:

      # CreatePrometheusRules defines whether the operator should install PrometheusRules
      # to receive alerts about the operator.
      createPrometheusRules: false

      # CreateServiceMonitors defines whether the operator should install ServiceMonitors
      # to scrape metrics of the operator.
      createServiceMonitors: false

  # OpenShift contains a set of feature gates supported only on OpenShift.
  openshift:

    # BaseDomain is used internally for redirect URL in gateway OpenShift auth mode.
    # If empty the operator automatically derives the domain from the cluster.
    baseDomain: ""

    # OauthProxy define options for the oauth proxy feature.
    oAuthProxy:

      # OAuthProxyEnabled is used internally for enable by default the oauth proxy for the UI when multi-tenancy is disabled.
      defaultEnabled: false

    # OpenShiftRoute enables creating OpenShift Route objects.
    # More details: https://docs.openshift.com/container-platform/latest/networking/understanding-networking.html
    openshiftRoute: false

    # ServingCertsService enables OpenShift service-ca annotations on the TempoStack
    # to use the in-platform CA and generate a TLS cert/key pair per service for
    # in-cluster data-in-transit encryption.
    # More details: https://docs.openshift.com/container-platform/latest/security/certificate_types_descriptions/service-ca-certificates.html
    #
    # Currently is only used in two cases:
    #   - If gateway is enabled, it will be used by the gateway component
    #   - If the gateway is disabled and TLS is enabled on the distributor but no caName and certName are specified
    servingCertsService: false

  # PrometheusOperator defines whether the Prometheus Operator CRD exists in the cluster.
  # This CRD is part of prometheus-operator.
  prometheusOperator: false

  # TLSProfile allows to chose a TLS security profile. Enforced
  # when using HTTPEncryption or GRPCEncryption.
  tlsProfile: ""

# Health contains the controller health configuration
health:

  # HealthProbeBindAddress is the TCP address that the controller should bind to
  # for serving health probes
  # It can be set to "0" or "" to disable serving the health probe.
  healthProbeBindAddress: ""

# Kind is a string value representing the REST resource this object represents.
# Servers may infer this from the endpoint the client submits requests to.
# Cannot be updated.
# In CamelCase.
# More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
kind: ""

# LeaderElection is the LeaderElection config to be used when configuring
# the manager.Manager leader election
leaderElection:

  # leaderElect enables a leader election client to gain leadership
  # before executing the main loop. Enable this when running replicated
  # components for high availability.
  leaderElect: false

  # leaseDuration is the duration that non-leader candidates will wait
  # after observing a leadership renewal until attempting to acquire
  # leadership of a led but unrenewed leader slot. This is effectively the
  # maximum duration that a leader can be stopped before it is replaced
  # by another candidate. This is only applicable if leader election is
  # enabled.
  leaseDuration: 0h

  # renewDeadline is the interval between attempts by the acting master to
  # renew a leadership slot before it stops leading. This must be less
  # than or equal to the lease duration. This is only applicable if leader
  # election is enabled.
  renewDeadline: 0h

  # resourceLock indicates the resource object type that will be used to lock
  # during leader election cycles.
  resourceLock: ""

  # resourceName indicates the name of resource object that will be used to lock
  # during leader election cycles.
  resourceName: ""

  # resourceName indicates the namespace of resource object that will be used to lock
  # during leader election cycles.
  resourceNamespace: ""

  # retryPeriod is the duration the clients should wait between attempting
  # acquisition and renewal of a leadership. This is only applicable if
  # leader election is enabled.
  retryPeriod: 0h

# Metrics contains the controller metrics configuration
metrics:

  # BindAddress is the TCP address that the controller should bind to
  # for serving prometheus metrics.
  # It can be set to "0" to disable the metrics serving.
  bindAddress: ""
  secure: false

# Webhook contains the controllers webhook configuration
webhook:

  # Port is the port that the webhook server serves at.
  # It is used to set webhook.Server.Port.
  port: 0
